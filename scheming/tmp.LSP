;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;  structure   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;1
(setq R '("R" ("1" nil) ("2" nil)))
(setq C1 '("C1" ("1" nil) ("2" nil)))
(setq C2 '("C2" ("1" nil) ("2" nil)))
(setq J1 '("J1" ("1" nil) ("2" nil)))
(setq J2 '("J2" ("1" nil) ("2" nil)))
(setq J3 '("J3" ("1" nil) ("2" nil)))
(setq J4 '("J4" ("1" nil) ("2" nil)))
(setq J5 '("J5" ("1" nil) ("2" nil)))
(setq OUT '("Out" ("1" nil) ("2" nil)))
(setq IN  '("In" ("1" nil) ("2" nil)))
(setq SA  '("SA" ("1" nil) ("2" nil)))
(setq GB  '("GB" ("1" nil) ("2" nil)))
(setq VT  '("VT" ("coll" nil) ("emit" nil) ("base" nil)))

(setq cxema '(R C1 C2 J1 J2 J3 J4 J5 OUT IN SA GB VT))
(setq cxema '(R C1 C2 J1 J2 J3 J4 J5 OUT IN SA GB VT))
(mapcar 'eval cxema)


;;;2
(setq C1 '(("element" "capacitor")("contacts" "1" "2")))
(setq VT1  '(("element" "transistor")("contacts" "base" "coll" "emit")()))


; 2.1 nj что параллельно то в списке, что последовательно - то отдельный список
circuit
((IN) (C1) (BLK))
BLK
( )


; 3 описываем тока св€зи
;св€зь прилош всетаки к выводу что нужно делать элементы joint - перекрестки св€зей

((IN "2")(C1 "1"))
	((C1 "2")(R "1"))
		((C1 "2")(VT1 "base"))
		((R "2")(VT1 "coll"))
			((R "2")(C2 "2"))
				((R "2")(OUT "1"))
				((OUT "2")(GB "1"))
				((GB "2")(SA "1"))
				((SA "2")(C2 "1"))
			((GB "2")(SA "1"))
....
;; прилош всетаки к выводу что нужно делать элементы joint - перекрестки св€зей

((IN "2")(C1 "1"))

((j3)(C1 "2"))
((j3)(R "1"))
((j3)(VT1 "base"))

((j1)(R "2"))
((j1)(VT1 "coll"))
((j1)(C2 "2"))
((j1)(OUT "1"))

((OUT "2")(GB "1"))
((GB "2")(SA "1"))

((j2)(SA "2"))
((j2)(C2 "1"))
((j2)(VT1 "emit"))
((j2)(IN "1"))


;;; пришол к выводу что в схеме соединений надо описывать —ќ≈ƒ»Ќ≈Ќ»я (умно ведь?))

((j4) (IN "2"))
((j4) (C1 "1"))

((j3)(C1 "2"))
((j3)(R "1"))
((j3)(VT1 "base"))

((j1)(R "2"))
((j1)(VT1 "coll"))
((j1)(C2 "2"))
((j1)(OUT "1"))

((j6) (GB "1"))
((j6) (OUT "2"))

((j5) (SA "1"))
((j5) (GB "2"))

((j2)(SA "2"))
((j2)(C2 "1"))
((j2)(VT1 "emit"))
((j2)(IN "1"))

;;; перепишеи соединени€ слеоующим образом

((j1) (R "2") (VT1 "coll") (C2 "2") (OUT "1"))
((j2) (SA "2") (C2 "1") (VT1 "emit") (IN "1"))
((j3) (C1 "2") (R "1") (VT1 "base"))
((j4) (IN "2") (C1 "1"))
((j5) (SA "1") (GB "2"))
((j6) (GB "1") (OUT "2"))

;;; а теперь вот так

((j 1) (R "2") (VT1 "coll") (C2 "2") (OUT "1"))
((j 2) (SA "2") (C2 "1") (VT1 "emit") (IN "1"))
((j 3) (C1 "2") (R "1") (VT1 "base"))
((j 4) (IN "2") (C1 "1"))
((j 5) (SA "1") (GB "2"))
((j 6) (GB "1") (OUT "2"))







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;  interface   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(connect '((R "1")(j5)))
(connect '((R "1")(j1)))

(connect '((GB "1")(out "2")))
(connect '((GB "2")(SA "1")))


(setq lst '((GB "2")(SA "1")))

;;;(defun connect (lst / )
;;;  (setq e1 (car lst) e2 (cadr lst))
;;;;;;  (setq (apply (car e1))
;;;;;;	 (subst
;;;;;;	   (list (cadr e1) e2)
;;;;;;	   (assoc (cadr e1) (cdr (eval (car e1))))
;;;;;;	   (eval (car e1))
;;;;;;	   ))
;;;  (apply 'setq (car e1)
;;;	 (subst
;;;	   (list (cadr e1) e2)
;;;	   (assoc (cadr e1) (cdr (eval (car e1))))
;;;	   (eval (car e1))
;;;	   ))
;;;  
;;;  (setq (car e2)
;;;	 (subst
;;;	   (list (cadr e2) e1)
;;;	   (assoc (cadr e2) (cdr (eval (car e2))))
;;;	   (eval (car e2))
;;;	   ))
;;;
;;;  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
